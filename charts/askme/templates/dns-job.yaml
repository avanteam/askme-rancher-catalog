{{- if .Values.dns.ovh.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "askme.fullname" . }}-dns-setup
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "askme.labels" . | nindent 4 }}
    app.kubernetes.io/component: dns-manager
  annotations:
    askme.avanteam.com/job-type: "dns-setup"
    askme.avanteam.com/depends-on: "secret-sync"
spec:
  ttlSecondsAfterFinished: 300
  selector:
    matchLabels:
      {{- include "askme.selectorLabels" . | nindent 6 }}
      app.kubernetes.io/component: dns-manager
  template:
    metadata:
      labels:
        {{- include "askme.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: dns-manager
    spec:
      restartPolicy: Never
      serviceAccountName: {{ include "askme.fullname" . }}-dns-manager
      containers:
      - name: ovh-dns-manager
        image: python:3.11-slim
        command:
        - /bin/bash
        - -c
        - |
          set -e
          echo "üåê Installation des d√©pendances OVH API..."
          # V√©rification des pr√©requis critiques
          echo "üîç V√©rification des secrets requis..."
          if [ -z "$OVH_APP_KEY" ] || [ -z "$OVH_APP_SECRET" ] || [ -z "$OVH_CONSUMER_KEY" ]; then
            echo "‚ùå ERREUR CRITIQUE: Secrets OVH manquants (OVH_APP_KEY, OVH_APP_SECRET, OVH_CONSUMER_KEY)"
            echo "üí° V√©rifiez que le secret 'ovh-local-dns-keys' existe dans le namespace {{ .Release.Namespace }}"
            exit 1
          fi
          
          echo "‚úÖ Secrets OVH d√©tect√©s"
          pip install --no-cache-dir requests
          
          echo "üìã Configuration DNS pour client: {{ .Release.Name }}"
          echo "üéØ Domaine cible: {{ .Values.client.domain }}"
          echo "üè∑Ô∏è Zone DNS: {{ .Values.dns.ovh.zone }}"
          
          # Variables
          CLIENT_SUBDOMAIN=$(echo "{{ .Values.client.domain }}" | sed 's/\.{{ .Values.dns.ovh.zone }}$//')
          TARGET_IP="{{ .Values.dns.ovh.targetIP }}"
          ZONE="{{ .Values.dns.ovh.zone }}"
          TTL="{{ .Values.dns.ovh.ttl }}"
          
          echo "üìù Sous-domaine: $CLIENT_SUBDOMAIN"
          
          # Auto-d√©tection IP si n√©cessaire (avec fallback s√©curis√©)
          if [ "$TARGET_IP" = "auto" ] || [ -z "$TARGET_IP" ]; then
            echo "üîÑ Recherche automatique de l'IP d'ingress..."
            
            # Attendre d'abord que l'ingress existe
            echo "‚è≥ Attente cr√©ation ingress..."
            for i in {1..15}; do
              if kubectl get ingress {{ include "askme.fullname" . }} -n {{ .Release.Namespace }} >/dev/null 2>&1; then
                echo "‚úÖ Ingress trouv√©"
                break
              fi
              echo "‚è≥ Ingress non trouv√©, attente... ($i/15)"
              sleep 10
            done
            
            # Maintenant chercher l'IP avec timeout et retry robuste
            for i in {1..20}; do
              # M√©thode 1: loadBalancer.ingress
              TARGET_IP=$(kubectl get ingress {{ include "askme.fullname" . }} -n {{ .Release.Namespace }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
              
              # M√©thode 2: annotations Rancher
              if [ -z "$TARGET_IP" ] || [ "$TARGET_IP" = "null" ]; then
                TARGET_IP=$(kubectl get ingress {{ include "askme.fullname" . }} -n {{ .Release.Namespace }} -o jsonpath='{.metadata.annotations.field\.cattle\.io/publicEndpoints}' 2>/dev/null | grep -o '"addresses":\["[^"]*"' | sed 's/.*"\([^"]*\)"/\1/' | head -1 || echo "")
              fi
              
              # M√©thode 3: service LoadBalancer
              if [ -z "$TARGET_IP" ] || [ "$TARGET_IP" = "null" ]; then
                TARGET_IP=$(kubectl get service -n {{ .Release.Namespace }} -o jsonpath='{.items[?(@.spec.type=="LoadBalancer")].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
              fi
              
              # Validation IP
              if [ -n "$TARGET_IP" ] && [ "$TARGET_IP" != "null" ] && [[ "$TARGET_IP" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
                echo "‚úÖ IP valide trouv√©e: $TARGET_IP"
                break
              fi
              
              echo "‚è≥ Recherche IP... ($i/20)"
              sleep 15
            done
            
            # Mode d√©grad√© : Utiliser IP par d√©faut si √©chec
            if [ -z "$TARGET_IP" ] || [ "$TARGET_IP" = "null" ] || ! [[ "$TARGET_IP" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
              echo "‚ö†Ô∏è Auto-d√©tection √©chou√©e, utilisation IP par d√©faut: {{ .Values.dns.ovh.targetIP }}"
              TARGET_IP="{{ .Values.dns.ovh.targetIP }}"
              
              if [ "$TARGET_IP" = "auto" ] || [ -z "$TARGET_IP" ]; then
                echo "‚ùå ERREUR: Aucune IP disponible (auto-d√©tection √©chou√©e + pas d'IP par d√©faut)"
                echo "üí° D√©finissez dns.ovh.targetIP avec une IP valide dans values.yaml"
                exit 1
              fi
            fi
          fi
          
          echo "üéØ IP cible finale: $TARGET_IP"
          
          # Script Python OVH API REEL
          python3 << 'PYTHON_EOF'
          import requests
          import json
          import hashlib
          import time
          import os
          import sys
          
          # Configuration OVH API depuis les variables d'environnement
          OVH_APP_KEY = os.environ['OVH_APP_KEY']
          OVH_APP_SECRET = os.environ['OVH_APP_SECRET'] 
          OVH_CONSUMER_KEY = os.environ['OVH_CONSUMER_KEY']
          OVH_ENDPOINT = os.environ['OVH_ENDPOINT']
          
          # Variables du DNS
          zone = os.environ['DNS_ZONE']
          subdomain = os.environ['DNS_SUBDOMAIN']
          target_ip = os.environ['DNS_TARGET_IP']
          ttl = int(os.environ['DNS_TTL'])
          
          # URLs API OVH selon l'endpoint
          api_endpoints = {
              'ovh-eu': 'https://eu.api.ovh.com/1.0',
              'ovh-ca': 'https://ca.api.ovh.com/1.0', 
              'ovh-us': 'https://api.us.ovhcloud.com/1.0'
          }
          
          base_url = api_endpoints.get(OVH_ENDPOINT, api_endpoints['ovh-eu'])
          
          def ovh_api_signature(method, query, body, timestamp):
              """G√©n√®re la signature pour l'API OVH"""
              s = '+'.join([
                  OVH_APP_SECRET,
                  OVH_CONSUMER_KEY, 
                  method.upper(),
                  query,
                  body,
                  str(timestamp)
              ])
              return '$1$' + hashlib.sha1(s.encode()).hexdigest()
          
          def ovh_api_call(method, path, data=None, retries=3):
              """Effectue un appel √† l'API OVH avec retry automatique"""
              for attempt in range(retries):
                  try:
                      query = base_url + path
                      body = json.dumps(data) if data else ''
                      timestamp = int(time.time())
                      
                      headers = {
                          'X-Ovh-Application': OVH_APP_KEY,
                          'X-Ovh-Consumer': OVH_CONSUMER_KEY,
                          'X-Ovh-Signature': ovh_api_signature(method, query, body, timestamp),
                          'X-Ovh-Timestamp': str(timestamp),
                          'Content-Type': 'application/json'
                      }
                      
                      # Timeout de 30 secondes pour √©viter les blocages
                      response = requests.request(method, query, headers=headers, data=body, timeout=30)
                      
                      if response.ok:
                          return response.json() if response.text else {}
                      
                      print(f"‚ö†Ô∏è Tentative {attempt + 1}/{retries} √©chou√©e: {response.status_code} - {response.text}")
                      
                      if attempt < retries - 1:
                          time.sleep(2 ** attempt)  # Backoff exponentiel
                          continue
                      else:
                          raise Exception(f"API Error apr√®s {retries} tentatives: {response.status_code}")
                          
                  except requests.exceptions.Timeout:
                      print(f"‚ö†Ô∏è Timeout tentative {attempt + 1}/{retries}")
                      if attempt < retries - 1:
                          time.sleep(2 ** attempt)
                      else:
                          raise Exception("Timeout API OVH apr√®s plusieurs tentatives")
                  except requests.exceptions.RequestException as e:
                      print(f"‚ö†Ô∏è Erreur r√©seau tentative {attempt + 1}/{retries}: {str(e)}")
                      if attempt < retries - 1:
                          time.sleep(2 ** attempt)
                      else:
                          raise Exception(f"Erreur r√©seau: {str(e)}")
              
              raise Exception("√âchec inattendu de l'appel API")
          
          def main():
              print(f"üåê Cr√©ation enregistrement DNS: {subdomain}.{zone} -> {target_ip}")
              print(f"üìç API OVH: {base_url}")
              print(f"‚è±Ô∏è TTL: {ttl}s")
              
              try:
                  # 1. V√©rifier si l'enregistrement existe d√©j√†
                  print("üîç V√©rification des enregistrements existants...")
                  existing_records = ovh_api_call('GET', f'/domain/zone/{zone}/record?fieldType=A&subDomain={subdomain}')
                  
                  # 2. Supprimer les anciens enregistrements si ils existent
                  for record_id in existing_records:
                      record_info = ovh_api_call('GET', f'/domain/zone/{zone}/record/{record_id}')
                      print(f"üóëÔ∏è Suppression ancien enregistrement: {record_info.get('subDomain', '')}.{zone} -> {record_info.get('target', '')}")
                      ovh_api_call('DELETE', f'/domain/zone/{zone}/record/{record_id}')
                  
                  # 3. Cr√©er le nouvel enregistrement
                  record_data = {
                      'fieldType': 'A',
                      'subDomain': subdomain,
                      'target': target_ip,
                      'ttl': ttl
                  }
                  
                  print(f"‚ûï Cr√©ation nouvel enregistrement DNS...")
                  new_record = ovh_api_call('POST', f'/domain/zone/{zone}/record', record_data)
                  print(f"‚úÖ Enregistrement cr√©√© avec l'ID: {new_record.get('id', 'N/A')}")
                  
                  # 4. Rafra√Æchir la zone DNS
                  print("üîÑ Rafra√Æchissement de la zone DNS...")
                  ovh_api_call('POST', f'/domain/zone/{zone}/refresh')
                  
                  print(f"üéâ DNS configur√© avec succ√®s!")
                  print(f"üìã R√©sultat: {subdomain}.{zone} -> {target_ip} (TTL: {ttl}s)")
                  
              except Exception as e:
                  print(f"‚ùå Erreur lors de la configuration DNS: {str(e)}")
                  sys.exit(1)
          
          if __name__ == "__main__":
              main()
          PYTHON_EOF
          
          echo "‚úÖ Configuration DNS termin√©e avec succ√®s!"
        
        envFrom:
        # Secret OVH synchronis√© dans le namespace local
        - secretRef:
            name: ovh-local-dns-keys
        
        env:
        - name: OVH_ENDPOINT
          value: {{ .Values.dns.ovh.endpoint | quote }}
        - name: DNS_ZONE
          value: {{ .Values.dns.ovh.zone | quote }}
        - name: DNS_SUBDOMAIN
          value: "{{ .Values.client.domain | replace (printf ".%s" .Values.dns.ovh.zone) "" }}"
        - name: DNS_TARGET_IP
          value: {{ .Values.dns.ovh.targetIP | quote }}
        - name: DNS_TTL
          value: {{ .Values.dns.ovh.ttl | quote }}
        
        resources:
          requests:
            memory: "128Mi"
            cpu: "200m"
          limits:
            memory: "256Mi"
            cpu: "500m"
{{- end }}