{{- if .Values.dns.ovh.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "askme.fullname" . }}-dns-setup-{{ .Chart.Version | replace "." "-" }}
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "askme.labels" . | nindent 4 }}
    app.kubernetes.io/component: dns-manager
  annotations:
    askme.avanteam.com/job-type: "dns-setup"
    askme.avanteam.com/depends-on: "secret-sync"
spec:
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      labels:
        {{- include "askme.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: dns-manager
    spec:
      restartPolicy: Never
      serviceAccountName: {{ include "askme.fullname" . }}-dns-manager
      containers:
      - name: ovh-dns-manager
        image: python:3.11-slim
        command:
        - /bin/bash
        - -c
        - |
          set -e
          echo "üåê Installation des d√©pendances OVH API..."
          # V√©rification des pr√©requis critiques
          echo "üîç V√©rification des secrets requis..."
          if [ -z "$OVH_APP_KEY" ] || [ -z "$OVH_APP_SECRET" ] || [ -z "$OVH_CONSUMER_KEY" ]; then
            echo "‚ùå ERREUR CRITIQUE: Secrets OVH manquants (OVH_APP_KEY, OVH_APP_SECRET, OVH_CONSUMER_KEY)"
            echo "üí° V√©rifiez que le secret 'ovh-local-dns-keys' existe dans le namespace {{ .Release.Namespace }}"
            exit 1
          fi
          
          echo "‚úÖ Secrets OVH d√©tect√©s"
          pip install --no-cache-dir requests
          
          echo "üìã Configuration DNS pour client: {{ .Release.Name }}"
          echo "üéØ Domaine cible: {{ .Values.client.domain }}"
          echo "üè∑Ô∏è Zone DNS: {{ .Values.dns.ovh.zone }}"
          
          # Variables
          CLIENT_SUBDOMAIN=$(echo "{{ .Values.client.domain }}" | sed 's/\.{{ .Values.dns.ovh.zone }}$//')
          TARGET_IP="{{ .Values.dns.ovh.targetIP }}"
          ZONE="{{ .Values.dns.ovh.zone }}"
          TTL="{{ .Values.dns.ovh.ttl }}"
          
          echo "üìù Sous-domaine: $CLIENT_SUBDOMAIN"
          
          # Auto-d√©tection IP si n√©cessaire (avec fallback s√©curis√©)
          if [ "$TARGET_IP" = "auto" ] || [ -z "$TARGET_IP" ]; then
            echo "üîÑ Recherche automatique de l'IP d'ingress..."
            
            # Attendre d'abord que l'ingress existe
            echo "‚è≥ Attente cr√©ation ingress..."
            for i in {1..15}; do
              if kubectl get ingress {{ include "askme.fullname" . }} -n {{ .Release.Namespace }} >/dev/null 2>&1; then
                echo "‚úÖ Ingress trouv√©"
                break
              fi
              echo "‚è≥ Ingress non trouv√©, attente... ($i/15)"
              sleep 10
            done
            
            # Maintenant chercher l'IP avec timeout et retry robuste
            for i in {1..20}; do
              # M√©thode 1: loadBalancer.ingress
              TARGET_IP=$(kubectl get ingress {{ include "askme.fullname" . }} -n {{ .Release.Namespace }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
              
              # M√©thode 2: annotations Rancher
              if [ -z "$TARGET_IP" ] || [ "$TARGET_IP" = "null" ]; then
                TARGET_IP=$(kubectl get ingress {{ include "askme.fullname" . }} -n {{ .Release.Namespace }} -o jsonpath='{.metadata.annotations.field\.cattle\.io/publicEndpoints}' 2>/dev/null | grep -o '"addresses":\["[^"]*"' | sed 's/.*"\([^"]*\)"/\1/' | head -1 || echo "")
              fi
              
              # M√©thode 3: service LoadBalancer
              if [ -z "$TARGET_IP" ] || [ "$TARGET_IP" = "null" ]; then
                TARGET_IP=$(kubectl get service -n {{ .Release.Namespace }} -o jsonpath='{.items[?(@.spec.type=="LoadBalancer")].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
              fi
              
              # Validation IP
              if [ -n "$TARGET_IP" ] && [ "$TARGET_IP" != "null" ] && [[ "$TARGET_IP" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
                echo "‚úÖ IP valide trouv√©e: $TARGET_IP"
                break
              fi
              
              echo "‚è≥ Recherche IP... ($i/20)"
              sleep 15
            done
            
            # Mode d√©grad√© : Utiliser IP par d√©faut si √©chec
            if [ -z "$TARGET_IP" ] || [ "$TARGET_IP" = "null" ] || ! [[ "$TARGET_IP" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
              echo "‚ö†Ô∏è Auto-d√©tection √©chou√©e, utilisation IP par d√©faut: {{ .Values.dns.ovh.targetIP }}"
              TARGET_IP="{{ .Values.dns.ovh.targetIP }}"
              
              if [ "$TARGET_IP" = "auto" ] || [ -z "$TARGET_IP" ]; then
                echo "‚ùå ERREUR: Aucune IP disponible (auto-d√©tection √©chou√©e + pas d'IP par d√©faut)"
                echo "üí° D√©finissez dns.ovh.targetIP avec une IP valide dans values.yaml"
                exit 1
              fi
            fi
          fi
          
          echo "üéØ IP cible finale: $TARGET_IP"
          
          # Script Python OVH API REEL
          python3 << 'PYTHON_EOF'
          import requests
          import json
          import hashlib
          import time
          import os
          import sys
          import re
          import ipaddress
          from urllib.parse import quote

          # Fonction de validation s√©curis√©e des entr√©es
          def validate_dns_inputs(zone, subdomain, target_ip, ttl, endpoint):
              """Validation stricte des param√®tres DNS pour pr√©venir les injections"""

              # Validation zone DNS (RFC 1035)
              if not isinstance(zone, str) or len(zone) == 0:
                  raise ValueError("Zone DNS vide ou invalide")
              if len(zone) > 253:
                  raise ValueError("Zone DNS trop longue (max 253 caract√®res)")
              # Pattern pour nom de domaine valide
              if not re.match(r'^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?(\.[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*\.[a-z]{2,}$', zone.lower()):
                  raise ValueError(f"Zone DNS invalide: {zone}")

              # Validation sous-domaine (RFC 1035)
              if not isinstance(subdomain, str) or len(subdomain) == 0:
                  raise ValueError("Sous-domaine vide ou invalide")
              if len(subdomain) > 63:
                  raise ValueError("Sous-domaine trop long (max 63 caract√®res)")
              # Alphanumerique + tirets, pas de tiret en d√©but/fin
              if not re.match(r'^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$', subdomain.lower()):
                  raise ValueError(f"Sous-domaine invalide: {subdomain}")

              # Validation adresse IP (IPv4 uniquement)
              if not isinstance(target_ip, str) or len(target_ip) == 0:
                  raise ValueError("Adresse IP vide ou invalide")
              try:
                  ip_obj = ipaddress.IPv4Address(target_ip)
                  # Rejeter les IP priv√©es/r√©serv√©es pour la s√©curit√©
                  if ip_obj.is_private or ip_obj.is_reserved or ip_obj.is_loopback:
                      print(f"‚ö†Ô∏è  Attention: IP priv√©e/r√©serv√©e d√©tect√©e: {target_ip}")
              except ipaddress.AddressValueError:
                  raise ValueError(f"Adresse IP IPv4 invalide: {target_ip}")

              # Validation TTL
              if not isinstance(ttl, int) or ttl < 60 or ttl > 86400:
                  raise ValueError(f"TTL invalide: {ttl} (doit √™tre entre 60 et 86400 secondes)")

              # Validation endpoint OVH
              valid_endpoints = ['ovh-eu', 'ovh-ca', 'ovh-us']
              if endpoint not in valid_endpoints:
                  raise ValueError(f"Endpoint OVH invalide: {endpoint}")

              print(f"‚úÖ Validation r√©ussie: {subdomain}.{zone} -> {target_ip} (TTL: {ttl}s)")
              return True

          # Configuration OVH API depuis les variables d'environnement
          try:
              OVH_APP_KEY = os.environ.get('OVH_APP_KEY', '').strip()
              OVH_APP_SECRET = os.environ.get('OVH_APP_SECRET', '').strip()
              OVH_CONSUMER_KEY = os.environ.get('OVH_CONSUMER_KEY', '').strip()
              OVH_ENDPOINT = os.environ.get('OVH_ENDPOINT', '').strip()

              # Validation des cl√©s OVH (longueurs minimales)
              if len(OVH_APP_KEY) < 10:
                  raise ValueError("OVH_APP_KEY manquante ou trop courte")
              if len(OVH_APP_SECRET) < 10:
                  raise ValueError("OVH_APP_SECRET manquante ou trop courte")
              if len(OVH_CONSUMER_KEY) < 10:
                  raise ValueError("OVH_CONSUMER_KEY manquante ou trop courte")

              # Variables du DNS
              zone = os.environ.get('DNS_ZONE', '').strip()
              subdomain = os.environ.get('DNS_SUBDOMAIN', '').strip()
              target_ip = os.environ.get('DNS_TARGET_IP', '').strip()
              ttl = int(os.environ.get('DNS_TTL', '300'))

              # VALIDATION CRITIQUE : V√©rifier tous les param√®tres
              print("üîê Validation des param√®tres DNS...")
              validate_dns_inputs(zone, subdomain, target_ip, ttl, OVH_ENDPOINT)

          except (ValueError, KeyError) as e:
              print(f"‚ùå ERREUR DE VALIDATION: {str(e)}")
              print("üí° V√©rifiez la configuration des variables d'environnement")
              sys.exit(1)
          except Exception as e:
              print(f"‚ùå ERREUR INATTENDUE lors de la validation: {str(e)}")
              sys.exit(1)
          
          # URLs API OVH selon l'endpoint
          api_endpoints = {
              'ovh-eu': 'https://eu.api.ovh.com/1.0',
              'ovh-ca': 'https://ca.api.ovh.com/1.0', 
              'ovh-us': 'https://api.us.ovhcloud.com/1.0'
          }
          
          base_url = api_endpoints.get(OVH_ENDPOINT, api_endpoints['ovh-eu'])
          
          def ovh_api_signature(method, query, body, timestamp):
              """G√©n√®re la signature pour l'API OVH"""
              s = '+'.join([
                  OVH_APP_SECRET,
                  OVH_CONSUMER_KEY, 
                  method.upper(),
                  query,
                  body,
                  str(timestamp)
              ])
              return '$1$' + hashlib.sha1(s.encode()).hexdigest()
          
          def ovh_api_call(method, path, data=None, retries=3):
              """Effectue un appel √† l'API OVH avec retry automatique"""
              for attempt in range(retries):
                  try:
                      query = base_url + path
                      body = json.dumps(data) if data else ''
                      timestamp = int(time.time())
                      
                      headers = {
                          'X-Ovh-Application': OVH_APP_KEY,
                          'X-Ovh-Consumer': OVH_CONSUMER_KEY,
                          'X-Ovh-Signature': ovh_api_signature(method, query, body, timestamp),
                          'X-Ovh-Timestamp': str(timestamp),
                          'Content-Type': 'application/json'
                      }
                      
                      # Timeout de 30 secondes pour √©viter les blocages
                      response = requests.request(method, query, headers=headers, data=body, timeout=30)
                      
                      if response.ok:
                          return response.json() if response.text else {}
                      
                      print(f"‚ö†Ô∏è Tentative {attempt + 1}/{retries} √©chou√©e: {response.status_code} - {response.text}")
                      
                      if attempt < retries - 1:
                          time.sleep(2 ** attempt)  # Backoff exponentiel
                          continue
                      else:
                          raise Exception(f"API Error apr√®s {retries} tentatives: {response.status_code}")
                          
                  except requests.exceptions.Timeout:
                      print(f"‚ö†Ô∏è Timeout tentative {attempt + 1}/{retries}")
                      if attempt < retries - 1:
                          time.sleep(2 ** attempt)
                      else:
                          raise Exception("Timeout API OVH apr√®s plusieurs tentatives")
                  except requests.exceptions.RequestException as e:
                      print(f"‚ö†Ô∏è Erreur r√©seau tentative {attempt + 1}/{retries}: {str(e)}")
                      if attempt < retries - 1:
                          time.sleep(2 ** attempt)
                      else:
                          raise Exception(f"Erreur r√©seau: {str(e)}")
              
              raise Exception("√âchec inattendu de l'appel API")
          
          def main():
              print(f"üåê Cr√©ation enregistrement DNS: {subdomain}.{zone} -> {target_ip}")
              print(f"üìç API OVH: {base_url}")
              print(f"‚è±Ô∏è TTL: {ttl}s")
              
              try:
                  # 1. V√©rifier si l'enregistrement existe d√©j√† (avec √©chappement URL)
                  print("üîç V√©rification des enregistrements existants...")
                  zone_escaped = quote(zone, safe='')
                  subdomain_escaped = quote(subdomain, safe='')
                  existing_records = ovh_api_call('GET', f'/domain/zone/{zone_escaped}/record?fieldType=A&subDomain={subdomain_escaped}')

                  # 2. Supprimer les anciens enregistrements si ils existent
                  for record_id in existing_records:
                      # Validation de l'ID d'enregistrement (doit √™tre num√©rique)
                      if not isinstance(record_id, int) or record_id <= 0:
                          print(f"‚ö†Ô∏è ID d'enregistrement invalide ignor√©: {record_id}")
                          continue

                      record_info = ovh_api_call('GET', f'/domain/zone/{zone_escaped}/record/{record_id}')
                      print(f"üóëÔ∏è Suppression ancien enregistrement: {record_info.get('subDomain', '')}.{zone} -> {record_info.get('target', '')}")
                      ovh_api_call('DELETE', f'/domain/zone/{zone_escaped}/record/{record_id}')

                  # 3. Cr√©er le nouvel enregistrement (donn√©es valid√©es)
                  record_data = {
                      'fieldType': 'A',  # Type fixe, pas d'injection possible
                      'subDomain': subdomain,  # D√©j√† valid√©
                      'target': target_ip,     # D√©j√† valid√©
                      'ttl': ttl               # D√©j√† valid√©
                  }

                  print(f"‚ûï Cr√©ation nouvel enregistrement DNS...")
                  new_record = ovh_api_call('POST', f'/domain/zone/{zone_escaped}/record', record_data)
                  record_id = new_record.get('id')
                  if isinstance(record_id, int) and record_id > 0:
                      print(f"‚úÖ Enregistrement cr√©√© avec l'ID: {record_id}")
                  else:
                      print(f"‚ö†Ô∏è Enregistrement cr√©√© mais ID invalide: {record_id}")

                  # 4. Rafra√Æchir la zone DNS
                  print("üîÑ Rafra√Æchissement de la zone DNS...")
                  ovh_api_call('POST', f'/domain/zone/{zone_escaped}/refresh')
                  
                  print(f"üéâ DNS configur√© avec succ√®s!")
                  print(f"üìã R√©sultat: {subdomain}.{zone} -> {target_ip} (TTL: {ttl}s)")
                  
              except Exception as e:
                  print(f"‚ùå Erreur lors de la configuration DNS: {str(e)}")
                  sys.exit(1)
          
          if __name__ == "__main__":
              main()
          PYTHON_EOF
          
          echo "‚úÖ Configuration DNS termin√©e avec succ√®s!"
        
        envFrom:
        # Secret OVH synchronis√© dans le namespace local
        - secretRef:
            name: ovh-local-dns-keys
        
        env:
        - name: OVH_ENDPOINT
          value: {{ .Values.dns.ovh.endpoint | quote }}
        - name: DNS_ZONE
          value: {{ .Values.dns.ovh.zone | quote }}
        - name: DNS_SUBDOMAIN
          value: "{{ .Values.client.domain | replace (printf ".%s" .Values.dns.ovh.zone) "" }}"
        - name: DNS_TARGET_IP
          value: {{ .Values.dns.ovh.targetIP | quote }}
        - name: DNS_TTL
          value: {{ .Values.dns.ovh.ttl | quote }}
        
        resources:
          requests:
            memory: "128Mi"
            cpu: "200m"
          limits:
            memory: "256Mi"
            cpu: "500m"
{{- end }}