# Job pour synchroniser les secrets globaux depuis askme-platform
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "askme.fullname" . }}-sync-global-secrets-{{ .Chart.Version | replace "." "-" }}
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "askme.labels" . | nindent 4 }}
    app.kubernetes.io/component: secret-sync
  annotations:
    askme.avanteam.com/job-type: "secret-sync"
spec:
  ttlSecondsAfterFinished: 300
  selector:
    matchLabels:
      {{- include "askme.selectorLabels" . | nindent 6 }}
      app.kubernetes.io/component: secret-sync
  template:
    metadata:
      labels:
        {{- include "askme.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: secret-sync
    spec:
      restartPolicy: Never
      serviceAccountName: {{ include "askme.fullname" . }}-dns-manager
      containers:
      - name: secret-sync
        image: bitnami/kubectl:latest
        command:
        - /bin/bash
        - -c
        - |
          set -e
          echo "üîê Synchronisation secrets globaux cross-namespace..."
          echo "üìã Source namespace: askme-platform"
          echo "üéØ Destination namespace: {{ .Release.Namespace }}"
          
          # Fonction utilitaire pour synchroniser un secret avec pr√©servation
          sync_secret() {
            local source_secret="$1"
            local target_secret="$2"
            local optional="$3"
            
            echo "üîç V√©rification du secret source: $source_secret"
            if kubectl get secret "$source_secret" -n askme-platform >/dev/null 2>&1; then
              echo "‚úÖ Secret $source_secret trouv√©"
              
              # V√©rifier si le secret local existe d√©j√†
              if kubectl get secret "$target_secret" -n "{{ .Release.Namespace }}" >/dev/null 2>&1; then
                echo "‚ö†Ô∏è  Secret $target_secret existe d√©j√† - pr√©servation des cl√©s personnalis√©es"
                
                # Ajouter uniquement l'annotation de protection sans modifier les donn√©es
                kubectl annotate secret "$target_secret" -n "{{ .Release.Namespace }}" \
                  "helm.sh/resource-policy=keep" --overwrite=true
                echo "üîí Secret $target_secret prot√©g√© avec annotation helm.sh/resource-policy=keep"
              else
                echo "üÜï Cr√©ation du nouveau secret $target_secret..."
                kubectl get secret "$source_secret" -n askme-platform -o json | \
                  jq --arg name "$target_secret" --arg namespace "{{ .Release.Namespace }}" \
                     '.metadata = {"name": $name, "namespace": $namespace, "annotations": {"helm.sh/resource-policy": "keep"}}' | \
                  kubectl apply -f -
                echo "‚úÖ Secret $target_secret cr√©√© avec annotation de protection"
              fi
            else
              if [ "$optional" = "true" ]; then
                echo "‚ö†Ô∏è  Secret $source_secret non trouv√© (optionnel)"
              else
                echo "‚ùå ERREUR: Secret requis $source_secret non trouv√© dans askme-platform"
                exit 1
              fi
            fi
          }
          
          {{- if .Values.dns.ovh.enabled }}
          # Synchroniser secret OVH (requis si DNS OVH activ√©)
          sync_secret "ovh-global-dns-keys" "ovh-local-dns-keys" "false"
          {{- else }}
          echo "üîï DNS OVH d√©sactiv√©, synchronisation OVH ignor√©e"
          {{- end }}
          
          # Synchroniser askme-tokens (REQUIS - tous les tokens LLM)
          sync_secret "askme-tokens" "askme-local-tokens" "false"
          
          # Synchroniser harbor-keys (REQUIS - authentification registry Docker)
          sync_secret "harbor-keys" "harbor-keys" "false"
          
          echo "üéâ Synchronisation des secrets termin√©e avec succ√®s!"
        
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"